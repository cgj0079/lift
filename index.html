<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>비행기 양력 애니메이션</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 30px;
            max-width: 1000px;
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 28px;
        }
        
        canvas {
            border: 3px solid #ddd;
            border-radius: 10px;
            display: block;
            background: #f8f9fa;
        }
        
        .controls {
            text-align: center;
            margin-top: 20px;
        }
        
        .button-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 15px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
            letter-spacing: 0.3px;
        }
        
        button:hover {
            background: linear-gradient(135deg, #5568d3 0%, #6a42a0 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }
        
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(102, 126, 234, 0.2);
        }
        
        button.active {
            background: #333;
            box-shadow: 0 4px 12px rgba(51, 51, 51, 0.35);
        }
        
        .climate-controls {
            display: flex;
            flex-direction: row;
            gap: 20px;
            margin-top: 15px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .climate-group {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 10px;
        }
        
        .climate-label {
            font-weight: 600;
            font-size: 13px;
            color: #555;
            min-width: 45px;
            text-align: center;
            letter-spacing: 0.5px;
        }
        
        .climate-buttons {
            display: flex;
            gap: 6px;
            justify-content: center;
            background: #f5f7fa;
            padding: 4px;
            border-radius: 10px;
        }
        
        .climate-btn {
            padding: 8px 16px;
            font-size: 15px;
            font-weight: 600;
            background: white;
            color: #4a90e2;
            border: 2px solid transparent;
            min-width: 44px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            letter-spacing: 0.5px;
        }
        
        .climate-btn:hover {
            background: #e8f0fe;
            color: #357abd;
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(74, 144, 226, 0.2);
        }
        
        .climate-btn:active {
            transform: translateY(0);
        }
        
        .climate-btn.active {
            background: #333;
            color: white;
            border-color: transparent;
            box-shadow: 0 2px 8px rgba(51, 51, 51, 0.3);
        }
        
        .climate-btn.zero {
            background: white;
            color: #7f8c8d;
        }
        
        .climate-btn.zero:hover {
            background: #f0f2f5;
            color: #5a6c7d;
        }
        
        .climate-btn.zero.active {
            background: #333;
            color: white;
            box-shadow: 0 2px 8px rgba(51, 51, 51, 0.3);
        }
        
        .info {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            line-height: 1.8;
        }
        
        .info p {
            margin: 8px 0;
            color: #333;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 15px;
            font-weight: bold;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .color-box {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 2px solid #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>비행기 양력 원리 애니메이션</h1>
        
        <canvas id="canvas" width="940" height="600"></canvas>
        
        <div class="legend">
            <div class="legend-item">
                <div class="color-box" style="background: #ff4444;"></div>
                <span>빠른 공기 (저압)</span>
            </div>
            <div class="legend-item">
                <div class="color-box" style="background: #44ff44;"></div>
                <span>일반 공기</span>
            </div>
            <div class="legend-item">
                <div class="color-box" style="background: #4444ff;"></div>
                <span>느린 공기 (고압)</span>
            </div>
        </div>
        
        <div class="controls">
            <div class="button-group">
                <button id="toggleBtn">일시정지</button>
            </div>
            <div style="margin-top: 15px;">
                <p style="font-weight: bold; margin-bottom: 10px; color: #333;">기후 조건 비교:</p>
                <div class="climate-controls">
                    <div class="climate-group">
                        <div class="climate-label">온도</div>
                        <div class="climate-buttons">
                            <button class="climate-btn" data-type="temperature" data-value="-1">-</button>
                            <button class="climate-btn zero active" data-type="temperature" data-value="0">0</button>
                            <button class="climate-btn" data-type="temperature" data-value="1">+</button>
                        </div>
                    </div>
                    <div class="climate-group">
                        <div class="climate-label">기압</div>
                        <div class="climate-buttons">
                            <button class="climate-btn" data-type="pressure" data-value="-1">-</button>
                            <button class="climate-btn zero active" data-type="pressure" data-value="0">0</button>
                            <button class="climate-btn" data-type="pressure" data-value="1">+</button>
                        </div>
                    </div>
                    <div class="climate-group">
                        <div class="climate-label">습도</div>
                        <div class="climate-buttons">
                            <button class="climate-btn" data-type="humidity" data-value="-1">-</button>
                            <button class="climate-btn zero active" data-type="humidity" data-value="0">0</button>
                            <button class="climate-btn" data-type="humidity" data-value="1">+</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="info">
            <p style="font-weight: bold; font-size: 16px; color: #667eea;">베르누이 원리:</p>
            <p>날개 위쪽: 곡선 형태로 공기가 더 긴 경로를 빠르게 이동 - 압력 감소 (저압)</p>
            <p>날개 아래쪽: 평평한 형태로 공기가 상대적으로 느리게 이동 - 압력 증가 (고압)</p>
            <p>이 압력 차이가 위로 향하는 양력을 발생시켜 비행기가 날 수 있다.</p>
        </div>
    </div>

    <script>
        // Canvas and basic state
        var canvas = document.getElementById('canvas');
        var ctx = canvas.getContext('2d');
        var width = canvas.width;
        var height = canvas.height;

        var isRunning = true;
        var particles = [];
        var frameCount = 0; // Add frame counter for more variation
        
        // Climate settings: -1 (low), 0 (normal), 1 (high)
        var climateSettings = {
            temperature: 0,
            pressure: 0,
            humidity: 0
        };

        // Calculate climate modifiers based on settings
        function getClimateModifiers() {
            var temp = climateSettings.temperature;
            var press = climateSettings.pressure;
            var hum = climateSettings.humidity;
            
            // Temperature effects: -1 (cold), 0 (normal), 1 (hot)
            var tempDensity = 1.0 + temp * -0.15; // Cold = higher density, Hot = lower density
            var tempSpeed = 1.0 + temp * 0.15; // Cold = slower, Hot = faster
            var tempPressure = 1.0 + temp * -0.1; // Cold = higher pressure, Hot = lower pressure
            
            // Pressure effects: -1 (low), 0 (normal), 1 (high)
            var pressDensity = 1.0 + press * 0.2; // Low = lower density, High = higher density
            var pressSpeed = 1.0 + press * -0.05; // Low = faster, High = slower
            var pressPressure = 1.0 + press * 0.3; // Low = lower pressure, High = higher pressure
            
            // Humidity effects: -1 (dry), 0 (normal), 1 (humid)
            var humDensity = 1.0 + hum * -0.05; // Dry = higher density, Humid = lower density
            var humSpeed = 1.0 + hum * 0.05; // Dry = slower, Humid = faster
            var humPressure = 1.0 + hum * -0.05; // Dry = higher pressure, Humid = lower pressure
            
            return {
                density: tempDensity * pressDensity * humDensity,
                speed: tempSpeed * pressSpeed * humSpeed,
                pressure: tempPressure * pressPressure * humPressure
            };
        }

        var airfoil = {
            x: width / 2 - 150,
            y: height / 2,
            length: 400,
            maxThickness: 60
        };

        // Helper function for more varied randomness
        function seededRandom(seed) {
            var x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }

        // Particle: represents an air particle in a streamline
        function Particle(x, y, streamline) {
            this.x = x;
            this.y = y;
            this.streamline = streamline; // -1..1 roughly (negative = top, positive = bottom)
            // Use timestamp and position for more unique randomness
            var uniqueSeed = Date.now() * 0.001 + x * 0.01 + y * 0.01 + Math.random() * 1000;
            this.randomSeed = uniqueSeed;
            var baseSpeedValue = 1.8 + seededRandom(uniqueSeed) * 1.2;
            // Store original base speed (without climate modifier) for later updates
            this.originalBaseSpeed = baseSpeedValue;
            // Apply climate modifier to base speed
            var climateMod = getClimateModifiers();
            this.baseSpeed = baseSpeedValue * climateMod.speed;
            this.speed = this.baseSpeed;
            this.size = 1.6 + seededRandom(uniqueSeed * 1.3) * 2.4;
            this.opacity = 0.6 + seededRandom(uniqueSeed * 1.7) * 0.4;
            this.tail = [];
            this.initialOffset = (seededRandom(uniqueSeed * 2.1) - 0.5) * 30; // Initial y offset variation
        }

        // return y on airfoil at x; isTop true -> top surface, false -> bottom
        Particle.prototype.getAirfoilY = function(x, isTop) {
            if (x < airfoil.x || x > airfoil.x + airfoil.length) return null;
            var relX = (x - airfoil.x) / airfoil.length;
            if (isTop) {
                var heightFactor = Math.sin(relX * Math.PI) * 1.2;
                return airfoil.y - airfoil.maxThickness * heightFactor;
            } else {
                var heightFactor = Math.sin(relX * Math.PI) * 0.3;
                return airfoil.y + airfoil.maxThickness * heightFactor;
            }
        };

        Particle.prototype.update = function() {
            // Move forward
            this.x += this.speed;

            // Wrap around
            if (this.x > width + 30) {
                // More varied reset position using frame count and unique seed
                var resetSeed = this.randomSeed + frameCount * 0.1;
                this.x = -30 - seededRandom(resetSeed) * 60;
                // reset y near its streamline band with more variation
                var yVariation = seededRandom(resetSeed * 1.5) * 40;
                this.y = height / 2 + this.streamline * (80 + yVariation) + this.initialOffset;
                this.speed = this.baseSpeed * (0.8 + seededRandom(resetSeed * 2.3) * 0.6);
                this.tail.length = 0;
            }

            // Influence zone: only adjust when near the airfoil's x-range
            var influenceLeft = airfoil.x - 140;
            var influenceRight = airfoil.x + airfoil.length + 140;
            if (this.x >= influenceLeft && this.x <= influenceRight) {
                var isTop = this.streamline < 0;
                var surfY = this.getAirfoilY(this.x, isTop);

                if (surfY !== null) {
                    // how far along the chord (0..1)
                    var relChord = (this.x - airfoil.x) / airfoil.length;
                    relChord = Math.max(0, Math.min(1, relChord));

                    // gaussian-like influence peaked near middle of wing
                    var mid = 0.45;
                    var sigma = 0.22;
                    var chordInfluence = Math.exp(-Math.pow((relChord - mid) / sigma, 2));

                    // offset from the surface - increased for more natural distance
                    // Start with larger offset, reduce gradually as particle approaches
                    var distanceFromStart = Math.max(0, this.x - influenceLeft);
                    var approachFactor = Math.min(1, distanceFromStart / 100); // Gradual approach
                    var streamlineStrength = Math.abs(this.streamline) * 12; // Reduced for top particles
                    // Reduce offset for top particles to prevent excessive upward movement
                    var baseOffset = isTop ? (25 + streamlineStrength * 0.6) : (35 + streamlineStrength);
                    var offset = (isTop ? -1 : 1) * (baseOffset * (0.7 + 0.3 * approachFactor));

                    // desired target position (not snapping)
                    var desiredY = surfY + offset;

                    // smoothing factor - reduced for more natural movement
                    var lerp = 0.025 + Math.abs(this.streamline) * 0.005; // Reduced from 0.04
                    lerp *= 0.5 + 0.5 * chordInfluence; // Weaker near edges
                    this.y += (desiredY - this.y) * lerp;

                    // speed modulation: top streamlines speed up a bit when over the wing
                    // Reduced pressure factor for top to prevent excessive upward movement
                    // Apply climate pressure modifier
                    var climateMod = getClimateModifiers();
                    var pressureFactor = (isTop ? 0.7 : -0.4) * chordInfluence * (0.6 + Math.abs(this.streamline) * 0.2) * climateMod.pressure;
                    // apply gentle change to speed
                    this.speed += (this.baseSpeed * (1 + pressureFactor) - this.speed) * 0.06;

                    // if too close to surface, push away smoothly (prevents sticking)
                    var minDist = 8 + Math.abs(this.streamline) * 1.2; // Increased minimum distance
                    var dist = Math.abs(this.y - surfY);
                    if (dist < minDist) {
                        var push = (minDist - dist) * 0.25;
                        this.y += (this.y < surfY ? -1 : 1) * push;
                        this.speed *= 0.98;
                    }
                }
            } else {
                // far from wing: relax speed back to base
                this.speed += (this.baseSpeed - this.speed) * 0.04;
                // drift slightly toward base streamline center
                var targetBandY = height / 2 + this.streamline * 90;
                this.y += (targetBandY - this.y) * 0.01;
                
                // Constrain particles from going too far up or down after wing interaction
                // Stricter constraint for top particles
                var centerY = height / 2;
                var isTop = this.streamline < 0;
                var maxDeviation = isTop ? 150 : 200; // Reduced for top particles
                if (Math.abs(this.y - centerY) > maxDeviation) {
                    var pullStrength = isTop ? 0.08 : 0.05; // Stronger pull for top particles
                    this.y += (centerY - this.y) * pullStrength;
                }
            }

            // Additional boundary constraints to prevent excessive vertical movement
            // Stricter upper boundary to prevent excessive upward movement
            var upperBoundary = 80; // Increased from 50
            var lowerBoundary = 50;
            if (this.y < upperBoundary) {
                this.y = upperBoundary + (upperBoundary - this.y) * 0.15; // Stronger push down
            } else if (this.y > height - lowerBoundary) {
                this.y = height - lowerBoundary - (this.y - (height - lowerBoundary)) * 0.1;
            }

            // record tail points
            this.tail.push({x: this.x, y: this.y});
            if (this.tail.length > 6) this.tail.shift();
        };

        // Helper function to interpolate color based on speed ratio
        function getGradientColor(ratio, isTop) {
            // Clamp ratio between 0.5 and 2.5 for color mapping
            ratio = Math.max(0.5, Math.min(2.5, ratio));
            
            var r, g, b;
            
            // Make top particles (fast air) more vibrant and distinct
            if (isTop && ratio > 1.2) {
                // Top particles that are fast: Bright orange-red to red
                if (ratio < 1.5) {
                    var t = (ratio - 1.2) / 0.3;
                    r = 255;
                    g = Math.floor(140 + (50 - 140) * t); // Orange to red
                    b = 0;
                } else {
                    // Very fast top particles: Bright red
                    r = 255;
                    g = 0;
                    b = 0;
                }
            } else if (ratio < 0.85) {
                // Slow: Blue to Cyan (0.5 to 0.85)
                var t = (ratio - 0.5) / 0.35;
                r = Math.floor(68 * (1 - t) + 0 * t);
                g = Math.floor(68 * (1 - t) + 255 * t);
                b = 255;
            } else if (ratio < 1.15) {
                // Normal: Cyan to Green (0.85 to 1.15)
                var t = (ratio - 0.85) / 0.3;
                r = 0;
                g = 255;
                b = Math.floor(255 * (1 - t) + 68 * t);
            } else if (ratio < 1.6) {
                // Fast: Green to Yellow to Red (1.15 to 1.6)
                var t = (ratio - 1.15) / 0.45;
                r = Math.floor(0 + 255 * t);
                g = 255;
                b = Math.floor(68 * (1 - t) + 0 * t);
            } else {
                // Very Fast: Red (1.6 to 2.5) - Make red more vibrant and visible
                var t = Math.min(1, (ratio - 1.6) / 0.9);
                r = 255;
                g = Math.floor(68 * (1 - t) + 0 * t);
                b = 0;
            }
            
            // Convert to hex
            var toHex = function(n) {
                var hex = Math.floor(n).toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            };
            return '#' + toHex(r) + toHex(g) + toHex(b);
        }

        Particle.prototype.draw = function() {
            // color based on speed relative to base with gradient
            var ratio = this.speed / this.baseSpeed;
            var isTop = this.streamline < 0;
            var color = getGradientColor(ratio, isTop);

            // Make fast (red) particles and top particles more visible
            var isFast = ratio > 1.4;
            var isTopFast = isTop && ratio > 1.2; // Top particles that are fast
            var drawSize = (isFast || isTopFast) ? this.size * 1.5 : this.size;
            var drawOpacity = (isFast || isTopFast) ? Math.min(1.0, this.opacity * 1.4) : this.opacity;

            // draw tail with gradient
            if (this.tail.length > 1) {
                ctx.beginPath();
                for (var i = 0; i < this.tail.length; i++) {
                    var p = this.tail[i];
                    if (i === 0) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                }
                ctx.strokeStyle = color;
                ctx.lineWidth = Math.max(1, drawSize * 0.7);
                ctx.globalAlpha = (isFast || isTopFast) ? 0.3 : 0.18;
                ctx.stroke();
            }

            // draw particle with gradient - make top fast particles stand out more
            ctx.beginPath();
            ctx.arc(this.x, this.y, drawSize, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.globalAlpha = drawOpacity;
            ctx.fill();
            
            // Add outline for fast particles and top particles to make them more visible
            if (isFast || isTopFast) {
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.globalAlpha = drawOpacity * 0.9;
                ctx.stroke();
            }
            
            ctx.globalAlpha = 1;
        };

        function initParticles() {
            particles = [];
            // create many particles across several streamlines
            var columns = 90; // number along x
            var streams = 18; // layers above and below
            var timeSeed = Date.now() * 0.001; // Use timestamp for variation
            var climateMod = getClimateModifiers();

            for (var c = 0; c < columns; c++) {
                var baseX = c * (width / columns) - 60;
                for (var s = -Math.floor(streams/2); s <= Math.floor(streams/2); s++) {
                    // skip exact center to keep some diversity
                    var streamline = s / (streams/2);
                    // Use seeded random for more variation
                    var seed = timeSeed + c * 0.1 + s * 0.05;
                    var jitterY = (seededRandom(seed) - 0.5) * 25; // Increased jitter
                    var yVariation = seededRandom(seed * 1.3) * 40;
                    var y = height / 2 + streamline * (80 + yVariation) + jitterY;
                    var xOffset = seededRandom(seed * 1.7) * 30;
                    var p = new Particle(baseX + xOffset, y, streamline);
                    // slightly vary base speed for realism using seeded random
                    var speedVariation = 0.9 + seededRandom(seed * 2.1) * 0.4;
                    p.originalBaseSpeed *= speedVariation;
                    p.baseSpeed = p.originalBaseSpeed * climateMod.speed;
                    particles.push(p);
                }
            }
        }
        
        function updateClimate(type, value) {
            climateSettings[type] = parseInt(value);
            // Update all particles with new climate modifiers
            var climateMod = getClimateModifiers();
            for (var i = 0; i < particles.length; i++) {
                var p = particles[i];
                // Recalculate base speed with new climate using original base speed
                if (p.originalBaseSpeed) {
                    p.baseSpeed = p.originalBaseSpeed * climateMod.speed;
                } else {
                    // Fallback: estimate original base speed
                    var estimatedOriginal = p.baseSpeed / (getClimateModifiers().speed || 1.0);
                    p.originalBaseSpeed = estimatedOriginal;
                    p.baseSpeed = estimatedOriginal * climateMod.speed;
                }
                p.speed = p.baseSpeed;
            }
            
            // Update button states for this type
            var buttons = document.querySelectorAll('.climate-btn[data-type="' + type + '"]');
            buttons.forEach(function(btn) {
                if (btn.dataset.value === value) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        function drawAirfoil() {
            ctx.fillStyle = '#2c3e50';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;

            ctx.beginPath();
            ctx.moveTo(airfoil.x, airfoil.y);

            ctx.bezierCurveTo(
                airfoil.x + airfoil.length * 0.2, airfoil.y - airfoil.maxThickness * 1.2,
                airfoil.x + airfoil.length * 0.6, airfoil.y - airfoil.maxThickness * 0.9,
                airfoil.x + airfoil.length, airfoil.y - 5
            );

            ctx.bezierCurveTo(
                airfoil.x + airfoil.length * 0.7, airfoil.y + airfoil.maxThickness * 0.25,
                airfoil.x + airfoil.length * 0.3, airfoil.y + airfoil.maxThickness * 0.15,
                airfoil.x, airfoil.y
            );

            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 2;
            for (var i = 1; i < 4; i++) {
                var x = airfoil.x + (airfoil.length / 4) * i;
                ctx.beginPath();
                ctx.moveTo(x, airfoil.y - 20);
                ctx.lineTo(x, airfoil.y + 10);
                ctx.stroke();
            }
        }

        function drawBackground() {
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            for (var i = 0; i < width; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, height);
                ctx.stroke();
            }
            for (var j = 0; j < height; j += 50) {
                ctx.beginPath();
                ctx.moveTo(0, j);
                ctx.lineTo(width, j);
                ctx.stroke();
            }
            ctx.setLineDash([]);
        }

        function animate() {
            if (!isRunning) return;

            frameCount++; // Increment frame counter for variation

            ctx.clearRect(0, 0, width, height);
            drawBackground();

            // update & draw particles (draw faster ones later for nicer overlap)
            for (var i = 0; i < particles.length; i++) particles[i].update();

            // sort by y for nicer layering
            particles.sort(function(a,b){ return a.y - b.y; });

            for (i = 0; i < particles.length; i++) particles[i].draw();

            drawAirfoil();

            // annotation
            ctx.fillStyle = '#ff6b6b';
            ctx.font = 'bold 24px Arial';
            ctx.fillText('↑', airfoil.x + airfoil.length / 2 - 10, airfoil.y - 100);
            ctx.font = '16px Arial';
            ctx.fillText('양력', airfoil.x + airfoil.length / 2 - 15, airfoil.y - 120);

            requestAnimationFrame(animate);
        }

        document.getElementById('toggleBtn').addEventListener('click', function() {
            isRunning = !isRunning;
            this.textContent = isRunning ? '일시정지' : '재생';
            if (isRunning) animate();
        });

        // Climate button event listeners
        var climateButtons = document.querySelectorAll('.climate-btn');
        climateButtons.forEach(function(btn) {
            btn.addEventListener('click', function() {
                var type = this.dataset.type;
                var value = this.dataset.value;
                updateClimate(type, value);
            });
        });

        // initialize
        initParticles();
        animate();
    </script>
</body>
</html>
